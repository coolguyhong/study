## 마이크로서비스 아키텍쳐(Micro Service Architect)

### 모노리틱 아키텍쳐(Monolithic Architecture)

#### 개념

- 기존의 전통적인 웹 시스템 개발 스타일
- 하나의 애플리케이션 내에 모든 로직들이 모두 들어가 있는 “통짜 구조”

#### 특징

- 각 컴포넌트들은 상호 호출을 함수를 이용한 call-by-reference 구조
- 개발툴 등에서 하나의 애플리케이션만 개발
- 배포 역시 간편하며 테스트도 하나의 애플리케이션만 수행하면 되기 때문에 편리

#### 문제점

- 규모가 큰 프로젝트에서는 빌드 및 배포 시간, 서버의 기동시간이 오래걸림
- 전체 시스템의 구조를 제대로 파악하지 않고 개발을 진행하면, 특정 컴포넌트나 모듈에서의 성능 문제나 장애가 다른 컴포넌트에까지 영향


### 마이크로 서비스 아키텍쳐

#### 개념

- SOA(Service Oriented Architecture : 서비스 지향 아키텍쳐) 사상에 근간
- 대용량 웹서비스 개발에 맞는 구조로 사상이 경량화 되고, 대규모 개발팀의 조직구조에 맞도록 변형된 아키텍쳐이다

#### 아키텍쳐 구조

- 서비스
    - 각 컴포넌트를 서비스라는 개념으로 정의
    - 데이타에서 부터 비지니스 로직까지 독립적으로 상호 컴포넌트간의 의존성이 없이 개발된 컴포넌트
    - 예를 들어 사용자 관리, 상품 관리, 주문 관리와 같은 각 업무 별로 서비스를 나눠서 정의
    - REST API에서 /users, /products와 같이 주요 URI도 하나의 서비스 정의의 범위로 좋은 예

- 마이크로 서비스 아키텍쳐의 구조
    - 각 컴포넌트는 서비스라는 형태로 구현되고 API를 이용하여 타 서비스와 통신
    - 각 서비스는 독립된 서버로 타 컴포넌트와의 의존성이 없이 독립적으로 배포
    - 애플리케이션 로직을 분리해서 여러개의 애플리케이션으로 나눠서 서비스화하고, 각 서비스별로 톰캣을 분산 배치

- 데이타 분리
    - 서비스가 API에서 부터 데이타 베이스까지 분리되는 수직 분할 원칙 (Vertical Slicing)에 따라서 독립된 데이타 베이스를 갖음
    - 다른 컴포넌트의 데이타를 API 통신을 통해서만 가지고 와야 하기 때문에 성능상 문제를 야기
    - 이 기종 데이타 베이스간의 트렌젝션을 묶을 수 없는 문제점

- API Gateway
    - proxy와 같은 개념임
    - EndPoint 통합 및 토폴로지 정리

- Orchestration
    - 여러개의 서비스를 묶어서 하나의 새로운 서비스를 만드는 개념이다.
    - 포인트 적립과, 물품 구매라는 서비스가 있을때, 이 두개의 서비스를 묶어서 “물품 구입시 포인트 적립”이라는 새로운 서비스
    - api gateway를 통해서 구현

- 공통 기능 처리 (Cross cutting function handling)
    - API에 대한 인증 (Authentication)이나, Logging과 같은 공통 기능에 대해서 서비스 컴포넌트 별로 중복 개발해야 하는 비효율성을 유발

#### 배포

- 각 서비스가 다른 서비스와 물리적으로 완벽하게 분리되기 때문에 변경이 있는 서비스 부분만 부분 배포가 가능

#### 확장성

- 부하가 많은 특정 서비스에 대해서만 확장이 가능하여 조금 더 유연한 확장 모델
- 부하를 많이 받는 서비스 컴포넌트 만 확장

#### Conway’s Law (컨웨이의 법칙)

- 소프트웨어의 구조는 그 소프트웨어를 만드는 조직의 구조와 일치한다
- 각 컴포넌트를 팀에 배치해서 책임지고 개발하는 것을 근간으로 하며, 팀간의 의존성을 제거해서 각 팀이 컴포넌트 개발을 독립적으로할 수 있는 구조로 잡혀있다.


### 마이크로 서비스 아키텍쳐의 문제점

#### 성능

- 값을 json이나 xml에서 프로그래밍에서 사용하는 데이타 모델 (java object등)으로 변환하는 marsharing 오버헤드가 발생
- 호출을 위해서 이 메세지들이 네트워크를 통해서 전송되기 때문에 그만한 시간이 더 추가로 소요

#### 메모리

- 중복되는 모듈에 대해서 그만큼 메모리 사용량이 늘어난다.
- 현재 인프라 구조에서는 크게 문제가 되지 않음

#### 테스팅이 더 어려움

- 특정 사용자 시나리오나 기능을 테스트하고자 할 경우 여러 서비스에 걸쳐서 테스트를 진행해야 하기 때문에 테스트 환경 구축이나 문제 발생시 분리된 여러개의 시스템을 동시에 봐야 하기 때문에 테스팅의 복잡도가 올라간다.

#### 서비스간 트렌젝션 처리

- API 기반의 여러 서비스를 하나의 트렌젝션으로 묶는 것은 불가능
- 계좌에서 돈을 빼는 서비스와, 계좌에 돈을 넣는 서비스가 있다고 하자. 이 둘은 API를 expose했을 때, 계좌에서 돈을 뺀 후, 계좌에 돈을 넣기 전에 시스템이 장애가 나면, 뺀 돈은 없어지게 된다
- 여러개의 API를 하나의 트렌젝션으로 묶는 분산 트렌젝션 시나리오 자체를 없애는 방안
- 그럼에도 불구하고, 트렌젝션 처리가 필요할 경우, 트렌젝션 실패시 이를 애플리케이션 적으로 처리해 줘야 하는 데, 이를 보상 트렌젝션 구현


### 거버넌스 모델

- 시스템을 개발하는 조직의 구조나 프로세스를 정의한 것으로, 일반적으로 중앙 집중화된 조직에서 표준 프로세스와 가이드를 기반으로 전체 팀을 운용하는 모델을 사용
- 전체 시스템이 동일한 프로세스와 기술을 가지고 개발이 되기 때문에, 유지 보수가 용이하고 팀간의 인원 교체등이 편리하다는 장점
- 전체 표준을 자바+RDBMS로 정했다 하더라도, 파일 업로드 다운로드 관련 컴포넌트는 io 성능과 많은 동시접속자를 처리할 수 있는 node.js가 유리하다던지, 데이타의 포맷은 복잡하지만, 복잡한 쿼리가 없을 경우에는 json document 기반의 mongodb와 같은 NoSQL등이 유리한 사례

#### Cross functional team

- 하나의 팀에 UX, 개발팀,인프라팀등 소프트웨어 시스템을 개발하는데 필요한 모든 역할을 하나의 팀에 구성하고 움직이는 모델로, 각 서비스 개발팀이 cross functional team이 되서 움직인다.

#### You build,You run-Devops

- Devops는 Development와 Operation을 합성한 단어로, 개발팀과 운영팀이 다른 팀으로 분리되어 있어서 발생하는 의사 소통의 문제점을 해결하고, 개발이 운영을 고려하고, 운영에서 발생하는 여러 문제점과 고객으로부터의 피드백을 빠르게 수용하여 서비스 개선에 반영하는 개발 모델


#### Project vs product

- 팀원의 영속성을 보장해줘야 하는데 이를 위해서는 프로젝트가 아니라 프로덕트(즉 상품)형태의 개념으로 개발 모델이 바뀌어야 한다. 팀은 상품에 대한 책임을 지고, 요구사항 정의 발굴에서 부터 개발 그리고 운영까지 책임을 지며, 계속해서 상품을 개선해 나가는 활동을 지속해야 한다. 이를 상품 중심의 개발팀 모델이라고 한다.


#### Self-organized team

- 팀은 독립적으로 서비스 개발을 할 수 있는 형태가 된다. 스스로 기획하고 개발하며 운영을 하며 스스로 서비스를 발전 시키는 하나의 회사와 같은 개념이 되는 것이다.

#### Alignment

- 우리는 전체 팀이 나가야 할 방향과 비지니스 밸류에 대해서 이해를 하고 있습니다. 또한 이미 팀간의 커뮤니케이션이나 전체 시스템 구조에 대한 이해를 하고 있습니다. 이를 바탕으로 조금 더 빠른 개발과 효율성을 위한 모든 기능(역할)을 가지고 있는 팀을 운영하고자 합니다.
